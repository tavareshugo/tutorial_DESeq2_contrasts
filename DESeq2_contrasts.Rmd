---
title: "Setting DESeq contrasts (using the model matrix)"
output: md_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, message=FALSE, echo=FALSE}
library(DESeq2)
```

# One factor, two levels

```{r}
# simulate data
dds <- makeExampleDESeqDataSet(n = 1000, m = 6, betaSD = 2)
dds$condition <- factor(rep(c("shade", "sun"), each = 3))
```

First we can look at our sample information:

```{r}
colData(dds)
```

We define our design and run DESeq model fitting:

```{r}
design(dds) <- ~ 1 + condition # or just `~ condition`
dds <- DESeq(dds) # equivalent to edgeR::glmFit()
```

Then check what coefficients DESeq estimated:

```{r}
resultsNames(dds)
```

We can see that we have a coefficient for our _intercept_ and coefficient for the effect of "sun" (i.e. differences between sun versus shade). 

We can then obtain the results for the effect of sun:

```{r}
res1 <- results(dds, contrast = list("condition_sun_vs_shade"))
res1
```

The above is a simple way to obtain the results of interest. 
But it is worth understanding how DESeq is getting to these results by looking at the model's matrix. 
DESeq uses standard R way to define the model matrix:

```{r}
model.matrix(design(dds), colData(dds))
```

We can see that R coded "condition" as s dummy variable, with an intercept (common to all samples) and a "conditionsun" variable, which adds the effect of sun to samples 4-6. 

We can actually set our contrasts in `DESeq2::results()` using a numeric vector. 
The way it works is to define a vector of "weights" for the coefficient(s) we want to test for.
In this case, we have `(Intercept)` and `conditionsun` as our coefficients (see model matrix above), and we want to test for the effect of sun, so our contrast vector would be `c(0, 1)`. 

In this case the design is very simple, but it can get difficult in more complex designs. 
So, it's worth mentioning the general way in which we can define this: 

```{r}
# get the model matrix
mod_mat <- model.matrix(design(dds), colData(dds))
mod_mat

# calculate weights for coefficients in each condition
sun <- colMeans(mod_mat[dds$condition == "sun", ])
sun
shade <- colMeans(mod_mat[dds$condition == "shade", ])
shade

# our contrast is
sun - shade

# get the results for this contrast
res2 <- results(dds, contrast = sun - shade)
```

And we can check that the results are the same: 

```{r}
plot(res1$log2FoldChange, res2$log2FoldChange)
```


## Recoding the design - no intercept

Often, we can use different model matrices that essentially correspond to the same design. 
For example, we could recode our design above by removing the intercept:

```{r}
design(dds) <- ~ 0 + condition
dds <- DESeq(dds)
resultsNames(dds)
```

In this case we get a coefficient corresponding to the average expression in shade and the average expression in the sun (rather than the _difference_ between sun and shade).

If we use the same contrast trick as before (using the model matrix), we can see the result is the same:

```{r}
# get the model matrix
mod_mat <- model.matrix(design(dds), colData(dds))
mod_mat

# calculate weights for coefficients in each condition
sun <- colMeans(mod_mat[which(dds$condition == "sun"), ])
sun
shade <- colMeans(mod_mat[which(dds$condition == "shade"), ])
shade

# our contrast is
sun - shade

res3 <- results(dds, contrast = sun - shade)
```

Again, the results are essentially the same:

```{r}
plot(res1$log2FoldChange, res3$log2FoldChange)
```

In theory there's no difference between these two ways of defining our design. 
The design with an intercept is more common, but for the purposes of understanding what's going on, it's sometimes easier to look at models without intercept. 


# One factor, three levels

```{r}
# simulate data
dds <- makeExampleDESeqDataSet(n = 1000, m = 9, betaSD = 2)
dds$condition <- NULL
dds$colour <- factor(rep(c("pink", "yellow", "white"), each = 3))
dds$colour <- relevel(dds$colour, "white")
colData(dds)
```

We define our design and fit the model:

```{r}
design(dds) <- ~ 1 + colour
dds <- DESeq(dds)
resultsNames(dds)
```

We see that now we have 3 coefficients: 

- "Intercept" corresponds to white colour (our reference level)
- "colour_pink_vs_white" corresponds to the difference between the reference level and pink
- "colour_yellow_vs_white" corresponds to the difference between the reference level and yellow

We could obtain the difference between white and any of the two colours easily:

```{r}
res1_pink_white <- results(dds, contrast = list("colour_pink_vs_white"))
res1_yellow_white <- results(dds, contrast = list("colour_yellow_vs_white"))

res1_pink_yellow <- results(dds, contrast = list("colour_pink_vs_white", 
                                                 "colour_yellow_vs_white"))
```

Again, we can define comparisons from the design matrix:

```{r}
mod_mat <- model.matrix(design(dds), colData(dds))
mod_mat

# calculate weights for coefficients in each group
pink <- colMeans(mod_mat[dds$colour == "pink", ])
pink
white <- colMeans(mod_mat[dds$colour == "white", ])
white
yellow <- colMeans(mod_mat[dds$colour == "yellow", ])
yellow
```

And we can now define any contrasts we want:

```{r}
res2_pink_white <- results(dds, contrast = pink - white)
res2_pink_yellow <- results(dds, contrast = pink - yellow)

# check they are identical
plot(res1_pink_white$log2FoldChange, res2_pink_white$log2FoldChange)
plot(res1_pink_yellow$log2FoldChange, res2_pink_yellow$log2FoldChange)
```

We could even say that we want to find genes that generally differ between pigmented and non-pigmented samples:

```{r}
# define vector of means for pigmented samples
pigmented <- colMeans(mod_mat[dds$colour %in% c("pink", "yellow"),])
pigmented

# this is our contrast now
pigmented - white

# get the results
res2_pigmented <- results(dds, contrast = pigmented - white)

# could have also set the contrast like this
(pink + yellow)/2 - white # average of pink and yellow minus white
```

We could have created a mock group in our column data:

```{r}
dds$pigmented <- factor(dds$colour %in% c("pink", "yellow"))
colData(dds)
```

and then re-run DESeq with a new design:

```{r}
design(dds) <- ~ 1 + pigmented
dds <- DESeq(dds)
resultsNames(dds)
res1_pigmented <- results(dds, contrast = list("pigmented_TRUE_vs_FALSE"))
```

However, in this model the gene dispersion is estimated together for pink and yellow samples, which may result in inflated estimates. 
Instead, our approach above correctly estimates the error within each of those groups. 

```{r}
plot(res1_pigmented$log2FoldChange, res2_pigmented$log2FoldChange); abline(0, 1, col = "brown")
plot(res1_pigmented$lfcSE, res2_pigmented$lfcSE); abline(0, 1, col = "brown")
```


# Two factors with interaction

```{r}
# simulate data
dds <- makeExampleDESeqDataSet(n = 1000, m = 12, betaSD = 2)
dds$colour <- factor(rep(c("pink", "white"), each = 6))
dds$colour <- relevel(dds$colour, "white")
dds$condition <- factor(rep(c("sun", "shade"), 6))
dds <- dds[, order(dds$colour, dds$condition)]
colnames(dds) <- paste0("sample", 1:ncol(dds))
```

Define our design and run the model:

```{r}
design(dds) <- ~ 1 + colour + condition + colour:condition
dds <- DESeq(dds)
resultsNames(dds)
```

Now we have an interaction, so we need to think about what it is we want to test for. 
Let's see how to do this with the model matrix (basically all the same we've been doing so far), and show the equivalent syntax using the coefficient names.

```{r}
mod_mat <- model.matrix(design(dds), colData(dds))
mod_mat

# Define vectors for each condition
pink_shade <- colMeans(mod_mat[dds$colour == "pink" & dds$condition == "shade", ])
pink_sun <- colMeans(mod_mat[dds$colour == "pink" & dds$condition == "sun", ])
white_shade <- colMeans(mod_mat[dds$colour == "white" & dds$condition == "shade", ])
white_sun <- colMeans(mod_mat[dds$colour == "white" & dds$condition == "sun", ])
```

Pink vs White (in the shade):

```{r}
res1 <- results(dds, contrast = pink_shade - white_shade)
res2 <- results(dds, contrast = list("colour_pink_vs_white"))
plot(res1$log2FoldChange, res2$log2FoldChange)
```

Pink vs White (in the sun):

```{r}
res1 <- results(dds, contrast = pink_sun - white_sun)
res2 <- results(dds, contrast = list(c("colour_pink_vs_white",
                                       "colourpink.conditionsun")))
plot(res1$log2FoldChange, res2$log2FoldChange)
```

Sun vs Shade (for whites):

```{r}
res1 <- results(dds, contrast = white_sun - white_shade)
res2 <- results(dds, contrast = list(c("condition_sun_vs_shade")))
plot(res1$log2FoldChange, res2$log2FoldChange)
```

Sun vs Shade (for pinks):

```{r}
res1 <- results(dds, contrast = pink_sun - pink_shade)
res2 <- results(dds, contrast = list(c("condition_sun_vs_shade", "colourpink.conditionsun")))
plot(res1$log2FoldChange, res2$log2FoldChange)
```

Interaction between colour and condition (i.e. do pinks and whites respond differently to the sun?):

```{r}
res1 <- results(dds, 
                contrast = (pink_sun - pink_shade) - (white_sun - white_shade))
res2 <- results(dds, contrast = list("colourpink.conditionsun"))
plot(res1$log2FoldChange, res2$log2FoldChange)
```

In conclusion, although we can define these contrasts using DESeq coefficient names, it is somewhat more explicit (and perhaps intuitive?) what it is we're comparing using matrix-based contrasts. 


# Three factors, with nesting

```{r}
# simulate data
dds <- makeExampleDESeqDataSet(n = 1000, m = 24, betaSD = 2)
dds$colour <- factor(rep(c("white", "pink"), each = 12))
dds$colour <- relevel(dds$colour, "white")
dds$species <- factor(rep(LETTERS[1:4], each = 6))
dds$condition <- factor(rep(c("sun", "shade"), 12))
dds <- dds[, order(dds$colour, dds$species, dds$condition)]
colnames(dds) <- paste0("sample", 1:ncol(dds))
```

Here, we define our design without including "colour". 
This is because colour is a linear combination with species (or, another way to think about it is that colour is redundant with species). 
So, we use "species" instead of colour, but later compare groups of species of the same colour with each other.

```{r}
design(dds) <- ~ 1 + species + condition + species:condition
dds <- DESeq(dds)
resultsNames(dds)
```

Now it's harder to define contrasts between groups of species of the same colour using DESeq's coefficient names (although still possible). 
But using the model matrix approach, we do it in exactly the same way we have done so far!

Again, let's define our groups from the model matrix:

```{r}
mod_mat <- model.matrix(design(dds), colData(dds))
mod_mat

# define coefficient vectors for each group
pink_shade <- colMeans(mod_mat[dds$colour == "pink" & dds$condition == "shade", ])
white_shade <- colMeans(mod_mat[dds$colour == "white" & dds$condition == "shade", ])
pink_sun <- colMeans(mod_mat[dds$colour == "pink" & dds$condition == "sun", ])
white_sun <- colMeans(mod_mat[dds$colour == "white" & dds$condition == "sun", ])
```

Now, it's worth looking at each of these vectors, to see that they are composed of a mixture of coefficients from different species:

```{r}
pink_shade
white_shade
```

These coefficients are weighted so that, for example, for "white" species, we have equal contribution from "speciesC" and "speciesD". 

When we define our contrasts, each species will be correctly weighted:

```{r}
pink_sun - pink_shade
```

We can set our contrasts in exactly the same way as we did in the previous section. 

For completeness, here's the contrasts using DESeq's named coefficients:

```{r}
res1_pink_white_shade <- results(dds, 
                           contrast = list(c("species_B_vs_A"),
                                           c("species_C_vs_A", "species_D_vs_A")))
res2_pink_white_shade <- results(dds, contrast = pink_shade - white_shade)

res1_pink_white_sun <- results(dds, 
                           contrast = list(c("species_B_vs_A",
                                             "speciesB.conditionsun"),
                                           c("species_C_vs_A", 
                                             "species_D_vs_A",
                                             "speciesC.conditionsun",
                                             "speciesD.conditionsun")))
res2_pink_white_sun <- results(dds, contrast = pink_sun - white_sun)

# didn't finish this... too much hassle
```


## Inbalanced design

Let's take our previous example, but drop one of the samples from the data, so that we only have 2 replicates for it.

```{r}
dds <- dds[, -13] # drop one of the species C samples
dds <- DESeq(dds)
resultsNames(dds)
```

Define our model matrix and coefficient vectors:

```{r}
mod_mat <- model.matrix(design(dds), colData(dds))
mod_mat

# define coefficient vectors for each group
pink_shade <- colMeans(mod_mat[dds$colour == "pink" & dds$condition == "shade", ])
white_shade <- colMeans(mod_mat[dds$colour == "white" & dds$condition == "shade", ])
pink_sun <- colMeans(mod_mat[dds$colour == "pink" & dds$condition == "sun", ])
white_sun <- colMeans(mod_mat[dds$colour == "white" & dds$condition == "sun", ])
```

Now let's check what happens to the pink_shade group:

```{r}
pink_shade
```

Notice that whereas before "speciesC" and "speciesD" had each a weight of 0.5, now they have different weights. 
That's because for speciesC there's only 2 replicates.
So, we have a total of 5 white individuals in the shade (2 from species C and 3 from D). 
Therefore, when we calculate the average coefficients for pinks, we need to do it as 0.4 x speciesC + 0.6 x speciesD. 

The nice thing about this approach is that we do not need to worry about any of this, the weights come from our `colMeans()` call automatically. 
And now, any contrasts that we make will take these weights into account:

```{r}
# pink vs white (in the shade)
pink_shade - white_shade

# interaction
(pink_sun - pink_shade) - (white_sun - white_shade)
```


# Further reading

- Nested design: http://seqanswers.com/forums/showthread.php?t=47766

(would be good to know if there is a central place with documentation about this)



